Delegation #1. 基礎(Objective-C)

1. 기본적으로 뷰가 delegate를 사용하게 될 것이고 뷰가 메시지를 보내길 원한다면 언제든지 호출될 것이다 왜냐하면 delegate가 프로토콜 메소드를 실행한다는 것을 알고 
있으니까 그 다음에 컨트롤러는 이 프로토콜을 실행한다고 선언해야 하고 프로토콜을 넣어줄텐데 예를들어 UIViewController, 다음에 프로토콜이 들어가게 될 것이다 그리고 
나서 컨트롤러는 자기자신(self)를 delegate라고 지정한다 즉, 자기자신을 이 프로퍼티로 설정하는 것이다 이렇게 하면 뷰가 델리게이트에게 말을 하면 컨트롤러에게 말을 하
게 되는 것이다 그래서 컨트롤러는 프로토콜을 실행한다

2. 델리게이트는 Object-C의 언어로 만들어져 있기 때문에 IOS에서 볼 수 있는 거의 모든 프로토콜은 옵셔널이다 왜냐하면 ScrollView가 어느 지점으로 스크롤을 지금 막 
끝냈는지 신경 쓰고 싶지 않을지도 모르며 그럼 ScrollViewDidScroll 같은 메소드를 받고 싶지 않을테고 그러니까 실행할 필요도 없을 것이다. 이제 뷰는 컨트롤러에 연결
된 상태지만 뷰는 아직도 아무것도 모르고 어떤 오브젝트가 will, should, did를 실행하고 있는지 꼭 클래스가 아닐수도 있고, 구조체일수도 있다 물론 @objc가 있는것은 
반드시 클래스가 되어야 할 테지만 그게 정확히 뭔지는 알 수 없고 그래서 Blind(무대뒤에서 이루어지는)라고 하는건데 그러면서도 구조화되어 있다고 할 수 있다. 프로토콜은 
보내져야 할 메소드를 정확하게 말할 것이니까 

#고차 함수(Higher-order function)

클로저 문법과 고차함수. 고차함수란 하나 이상의 함수를 인자로 취하거나 함수를 결과로 반환하는 함수 Swift의 고차 함수인 map, filter, reduce에 대해 알아보자

#map - 컬렉션 내부의 기존 데이터를 변형해서 새로운 컬렉션을 생성하는 함수

					MAP
	
	-콜렉션 내부의 기존 데이터를 변형(transform)하여 새로운 콜렉션 생성

		container.map(f(x)) 컨테이너의 map 메소드 호출


			> return f(container의 각 요소)
			// 새로운 컨테이너가 된다


내부의 자료에 변형을 가하기 위해 함수의 각 요소에 함수를 적용해서 새로운 컬렉션을 만들어준다. 잘 사용하면 for문을 사용하지 않고도 작업가능

	1 let numbers: [Int] = [0, 1, 2, 3, 4]
	2 var doubledNumbers: [Int] = [Int]()
	3 var string: [String] = [String]()
	4
	5 	//for for number in numbers {
	6	doubledNumbers.append(number * 2)
	7	strings.append("(number)")
	8 }
	9
	10 print(doubledNumbers) // [0, 2, 4, 6, 8]
	11 print(strings) // ["0", "1", "2", "3", "4"]

같은 로직으로 map을 적용

	1 // map 메소드 적용
	2 doubledNumbers = numbers.map({ (number: Int) -> Int in
	3	return number * 2
	4 })
	5 string = number.map({ (number: Int) -> Int in
	6	return "(number)"
	7})
	8
	9 print(doubledNumbers) // [0, 2, 4, 6, 8]
	10 print(strings) // ["0", "1", "2", "3", "4"]

map을 사용하면 numbers라는 배열에 map을 통해 함수를 적용해서 요소 하나하나에 변형을 가해줘서 기존요소에 2배를 한 새로운 배열이 만들어집니다.

	1 // 매개변수, 반환 타입, 반환 키워드 (return) 생략
	2 // 후행 클로저
	3 doubleNumbers = numbers.map { $0 * 2 }
	4 print(doubledNumbers) // [0, 2, 4, 6, 8]

앞서 말한 생략기법을 사용하면 가독성 높아진다

#필터(filter) - 컨테이너 내부의 값을 걸러서 추출 

	1 let numbers: [Int] = [0, 1, 2, 3, 4, 5]
	2 var evenNumbers: [Int] = [Int]()
	3
	4 //for 구문 사용
	5 for number in numbers {
	6	if number % 2 != 0 {continue}
	7	evenNumbers.append(number)
	8 }
	9
	10 print(evenNumber) // [ 0, 2, 4 ]

짝수를 골라내기 위해 for문을 사용하면 위와 같은 모습입니다.

	1 let numbers: [Int] = [0, 1, 2, 3, 4, 5]
	2 let evenNumbers: [Int] = numbers.filter { ( number: Int) -> Bool in return number % 2==0 }
	3 print(evenNumbers) // [0, 2, 4]

앞서와 마찬가지로 한줄로 축약 가능 map과는 용도만 다름

#리듀스(reduce) - 컨테이너 내부의 컨텐츠를 하나로 통합 

	1 let numbers: [Int] = [2, 8, 15]
	2 var sum: Int = 0
	3
	4 for number in numbers {
	5	sum += number
	6 }
	7
	8 print(sum) // 25

컬렉션의 모든 내용을 합침

	1 numbers: [Int] = [2, 8, 15] // 0

	// 초깃값이 0이고 정수 배열의 모든 값을 더함
	2 let sum: [Int] = numbers.reduce { ( first: Int, second: Int) - > Int in
	3 print("(first) + (second)")
	4 	retrun first + second
	5 })
	6
	7 print(sum) // 25

sum이라는 let상수에 값을 더하는데, 뒤에 값을 바꾸는 로직이 없으므로 상수를 사용할 수 있습니다. 앞서 for문에서는 var변수로 선언해야 하기 때문에 나중에 의도하지 않게 값을 변화할 여지가 있으므로 고차원 함수로 사용하면 이런 실수를 줄일 수 있다는 장점이있다.

	1 let numbers: [Int] = [2, 8, 15]
	
	//초깃값이 0이고 정수, 배열의 모든값을 뺌
	2 let subtract: Int = numbers.reuce(0, {(first: Int, second: Int) -> Int in
	3 print("(first) - (second)")
	4	return first - second
	5 })
	6
	7 print(subtract) // - 25

	
	// 초기값이 3이고 정수 배열의 모든 값을 더함
	1 let sumFromThree = numbers.reduce(3) { $0 + $1 }
	2 print(sumFromThree) // 28

	/* var sum: Int = 3
		for number in numbers {
		sum += number
	}
	*/

초깃값을 0이 아닌 3으로 지정도 가능



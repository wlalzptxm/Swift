#Objects and Classes

class를 생성하기 위해 클래스 이름 다음에 클래스를 생성하자, class안의 컨택스트(context)를 제외하고 class의 속성 선언은 변수나 상수의 선언과 같은 방법이다, 비슷하게 메소드나 함수 선언도 같은 방식으로 작성할 수 있다.

	1 class Shape {
	2	var numberOfSides = 0
	3	func simpleDescription() -> String
	4		return "A shape with \(numberOfSides) sides."
	5	}
	6 }

	EXPERIMENT
	불변 속성으로 let을 추가, 그리고 인자를 받는 다른 메소드도 추가해보자

class 이름 뒤에 괄호를 넣어, 클래스의 인스턴스를 생성해보자. 인스턴스의 메소드와 속성에 접속하는 . 구문을 사용하보자

	1 var shape = Shape()
	2 shape.numberOfSides = 7
	3 var shapeDescription = shape.simpleDescription()

이 Shape 클래스는 어떤 중요한 것을 잊어먹은 버전이다 : 인스턴스가 생성될 때 클래스를 설정하는 초기화 프로그램
init을 생성하는 것으로 사용해보자


	1 class NamedShape {
	2	var numberOfSides: Int = 0
	3	var name: String
	4
	5	init(name: String) {
	6		self.name = name
	7	}
	8
	9	func simpleDescription() -> String {
	10		return	"A shape with \(numberOfSides) sides."
	11	}
	12 }

name의 초기화 인자로 부터 name 속성이 구별되기 위해 self가 어떻게 사용되는지 주목하자, 초기화에 대한 인수는 함수 호출(클래스의 인스턴스를 만들때)과 같이 전달된다. 모든 속성은 할당된 값이 필요하다- 선언(numberOfSides와 같이) 또는 초기화(name와 같이)

deinit를 사용하여 초기화도구를 만든다 만약 할당이 해제된 오브젝트에 실행 한것을 정리하는 것이 필요하다면,

서브 클래스는 클래스 이름 뒤에 슈퍼클래스(부모클래스) 이름을 포함하고 콜론(,)에 의해 나뉘어진다. 클래스가 표준 루트 클래스(?)를 하위 클래스로 만들 필요는 없다. 그러니 필요에 따라 수퍼클래스를 포함하거나 누락 할수 있다.

슈퍼 클래스의 구현을 오버라이드하는 서브클래스의 메소드는 오버라이드를 하지 않고 급작스럽게 오버라이드로 마크되어 컴파일러에 의해 에러로서 검출된다. 또한 컴파일러는 override와 함꼐 메소드를 발견한다 - 실제로는 슈퍼클래스 안의 어떠한 메소드도 재정의(override)하지 않는다

	1 class Square: NamedShape {
	2	var sideLength: Double
	3
	4	init(sideLength: Double, name:String) {
	5		self.sideLength = sideLength
	6		super.init(name: name)
	7		numberOfSide = 4
	8	}
	9
	10	func area() - > Double {
	11		return sideLength * sideLength
	12	}
	13
	14





